package main

import (
	"fmt"
	"math/rand/v2"
)

func main() {
	testCases := [][]int{
		{},
		{1},
		{3, 1, 2},
		{9, 5, 7, 3, 1, 8, 6, 2, 4},
		{64, 34, 25, 12, 22, 11, 90},
		{5, 2, 8, 1, 9, 3, 7, 4, 6},
		{3, 3, 3, 3, 3},
		{-5, 0, 2, -8, 4, -3, 1},
	}

	for i, arr := range testCases {
		fmt.Printf("\nТест %d:\n", i+1)
		fmt.Printf("До сортировки:    %v\n", arr)

		arrCopy := make([]int, len(arr))
		copy(arrCopy, arr)

		Sort(arrCopy)
		fmt.Printf("После сортировки: %v\n", arrCopy)
	}
}

// Sort
// Сортирует переданный срез целых чисел по возрастанию на месте (in-place).
//
// Параметры:
//
//	source: срез целых чисел для сортировки
func Sort(source []int) {
	if len(source) < 2 {
		return
	}
	quickSort(source, 0, len(source)-1)
}

// quickSort рекурсивно сортирует подмассив от low до high используя алгоритм быстрой сортировки.
// Для оптимизации использования стека вызовов используется хвостовая рекурсия:
// сначала сортируется меньший из двух подмассивов, затем повторяется цикл для большего.
//
// Параметры:
//
//	arr: срез для сортировки
//	low: начальный индекс подмассива
//	high: конечный индекс подмассива
func quickSort(arr []int, low, high int) {
	// Используем цикл вместо рекурсии для большего подмассива (оптимизация хвостовой рекурсии)
	for low < high {
		// Разделяем массив и получаем индекс опорного элемента
		p := partition(arr, low, high)

		// Определяем какой подмассив меньше и сначала сортируем его рекурсивно,
		// затем продолжаем итеративно для большего подмассива
		if p-low < high-p {
			// Левый подмассив меньше - сортируем его рекурсивно
			quickSort(arr, low, p-1)
			// Переходим к правому подмассиву (итеративно)
			low = p + 1
		} else {
			// Правый подмассив меньше - сортируем его рекурсивно
			quickSort(arr, p+1, high)
			// Переходим к левому подмассиву (итеративно)
			high = p - 1
		}
	}
}

// partition разделяет подмассив arr[low:high] на две части относительно опорного элемента
// и возвращает конечную позицию опорного элемента.
//
// Алгоритм:
//  1. Выбирается случайный опорный элемент для избежания худшего случая O(n²)
//  2. Опорный элемент перемещается в конец
//  3. Все элементы меньше опорного перемещаются влево
//  4. Опорный элемент ставится на свою окончательную позицию
//
// Параметры:
//
//	arr: срез для разделения
//	low: начальный индекс
//	high: конечный индекс
//
// Возвращает:
//   - Индекс опорного элемента после разделения
func partition(arr []int, low, high int) int {
	// Выбираем случайный опорный элемент для избежания худшего случая
	// когда массив уже отсортирован или содержит одинаковые элементы
	pivotIndex := low + rand.IntN(high-low+1)
	pivot := arr[pivotIndex]

	// Перемещаем опорный элемент в конец для удобства обработки
	arr[pivotIndex], arr[high] = arr[high], arr[pivotIndex]

	// i указывает позицию, где будет размещен следующий элемент меньший чем опорный
	i := low

	// Проходим по всем элементам кроме опорного (он в конце)
	for j := low; j < high; j++ {
		if arr[j] < pivot {
			// Найден элемент меньший чем опорный - перемещаем его в левую часть
			arr[i], arr[j] = arr[j], arr[i]
			i++
		}
	}

	// Ставим опорный элемент на свою окончательную позицию
	// Все элементы слева от i меньше опорного, справа - больше или равны
	arr[i], arr[high] = arr[high], arr[i]

	return i
}
